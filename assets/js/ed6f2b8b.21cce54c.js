"use strict";(self.webpackChunktm_docs=self.webpackChunktm_docs||[]).push([[826],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return f}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),p=u(n),f=o,m=p["".concat(s,".").concat(f)]||p[f]||l[f]||a;return n?r.createElement(m,i(i({ref:t},d),{},{components:n})):r.createElement(m,i({ref:t},d))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=p;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var u=2;u<a;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},3419:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return i},default:function(){return l},frontMatter:function(){return a},metadata:function(){return c},toc:function(){return u}});var r=n(3117),o=(n(7294),n(3905));const a={id:"reducers",title:"Extending data formatting"},i=void 0,c={unversionedId:"Advanced/reducers",id:"Advanced/reducers",title:"Extending data formatting",description:"With Trial Monitor we try to do some educated guesses regarding how data is structured based on each database type. Once data is retrieved it goes through its internal functions to be formatted so it can be interpreted by the UI components. While this works in many situations, sometimes additional processing may be required. For instance, data might be stored in a structured not supported by the frontend (e.g. stringified JSON), or you need to transform the data (e.g. calculate the score of a questionnaire based on raw data). Understanding these use cases, it is possible to write your own parsing functions to have control over the formatting process.",source:"@site/docs/04-Advanced/reducers.md",sourceDirName:"04-Advanced",slug:"/Advanced/reducers",permalink:"/trial-monitor/Advanced/reducers",draft:!1,tags:[],version:"current",frontMatter:{id:"reducers",title:"Extending data formatting"},sidebar:"tutorialSidebar",previous:{title:"Custom permissions",permalink:"/trial-monitor/Advanced/custom-permissions"}},s={},u=[{value:"Creating the reducer function",id:"creating-the-reducer-function",level:2},{value:"Using the reducer",id:"using-the-reducer",level:2}],d={toc:u};function l(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"With Trial Monitor we try to do some educated guesses regarding how data is structured based on each database type. Once data is retrieved it goes through its internal functions to be formatted so it can be interpreted by the UI components. While this works in many situations, sometimes additional processing may be required. For instance, data might be stored in a structured not supported by the frontend (e.g. stringified JSON), or you need to transform the data (e.g. calculate the score of a questionnaire based on raw data). Understanding these use cases, it is possible to write your own parsing functions to have control over the formatting process."),(0,o.kt)("p",null,"This can be accomplished by writing a reducer function that receives data as input, perform a set of operations over it and return the resulting data as an output."),(0,o.kt)("h2",{id:"creating-the-reducer-function"},"Creating the reducer function"),(0,o.kt)("p",null,"To create a new reducer function:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Add a new ",(0,o.kt)("inlineCode",{parentName:"li"},"index.js")," to the ",(0,o.kt)("inlineCode",{parentName:"li"},"config/reducers")," directory"),(0,o.kt)("li",{parentName:"ol"},"Export a function that will transform your data")),(0,o.kt)("p",null,"That function will receive two arguments. The first argument is the data retrieved from the database without any processing; the second argument contains the component specification."),(0,o.kt)("p",null,"Within that function, transform the data according to your requirements and return the resulting data. Each UI component will expected different data structures, so check the documentation of the component for details of how data should be returned."),(0,o.kt)("p",null,"Example of a reducer function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const customReducer = (data, component) => {\n  return data.map(row => {\n    return {\n      ...row,\n      newColumn: parseInt(row.value) * 2.13\n    }\n  })\n}\n\nmodule.exports { customReducer }\n")),(0,o.kt)("h2",{id:"using-the-reducer"},"Using the reducer"),(0,o.kt)("p",null,"Reducer functions can be applied to one of more Data Components. On the specifications of the component, add a new property named ",(0,o.kt)("inlineCode",{parentName:"p"},"reducer")," with the value corresponding to the name of the function you are exporting"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"reducer: customReducer\n")))}l.isMDXComponent=!0}}]);